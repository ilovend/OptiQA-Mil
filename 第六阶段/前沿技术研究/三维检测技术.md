# 三维检测技术学习笔记 — 框架

说明：本文件为学习三维检测技术的笔记框架，后续在对应小节补充要点、示例、习题与心得。

## 目录
- [3D检测技术概述](#3d检测技术概述)
- [结构光技术](#结构光技术)
- [双目立体视觉](#双目立体视觉)
- [TOF技术](#tof技术)
- [3D点云处理](#3d点云处理)
- [CAD模型匹配](#cad模型匹配)
- [表面缺陷检测](#表面缺陷检测)
- [尺寸测量与公差](#尺寸测量与公差)
- [系统标定与精度](#系统标定与精度)
- [三维重建应用](#三维重建应用)
- [学习资源与书签](#学习资源与书签)
- [学习进度与 TODO 列表](#学习进度与-todo-列表)

---

## 3D检测技术概述
- 3D检测的发展与分类
- 主动式与被动式3D技术比较
- 点云、网格与体素表示
- 3D检测系统组成
- 检测精度与分辨率因素
- 示例：
```python
# 3D检测技术对比与可视化
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.patches import FancyArrowPatch
from mpl_toolkits.mplot3d import proj3d

# 3D检测技术参数比较
techniques = ['结构光', '双目视觉', '飞行时间', '激光三角测量', '光场相机']
accuracy = [0.05, 0.2, 1.0, 0.01, 0.5]  # mm
range_min = [0.3, 0.5, 0.2, 0.1, 0.3]  # m
range_max = [2, 10, 10, 5, 3]  # m
cost = [3, 2, 4, 5, 4]  # 1-5相对成本
speed = [4, 3, 5, 2, 4]  # 1-5相对速度

# 创建雷达图比较不同技术
def radar_chart(techniques, metrics_dict):
    """绘制多指标雷达图"""
    # 准备数据
    metrics = list(metrics_dict.keys())
    n_metrics = len(metrics)
    angles = np.linspace(0, 2*np.pi, n_metrics, endpoint=False).tolist()
    angles += angles[:1]  # 闭合图形
    
    # 准备绘图
    fig, ax = plt.subplots(figsize=(10, 10), subplot_kw=dict(polar=True))
    
    # 为每种技术绘制一条线
    for i, technique in enumerate(techniques):
        values = [metrics_dict[metric][i] for metric in metrics]
        values += values[:1]  # 闭合图形
        
        ax.plot(angles, values, linewidth=2, linestyle='solid', 
                label=technique, marker='o', markersize=6)
    
    # 设置标签和刻度
    ax.set_theta_offset(np.pi / 2)
    ax.set_theta_direction(-1)
    ax.set_thetagrids(np.degrees(angles[:-1]), metrics)
    
    # 添加图例
    ax.legend(loc='upper right', bbox_to_anchor=(0.1, 0.1))
    
    plt.title('3D检测技术多指标对比', fontsize=15, pad=20)
    return fig, ax

# 归一化指标数据用于雷达图
def normalize_metrics():
    # 精度是越小越好，所以取倒数再归一化
    accuracy_norm = [1/acc for acc in accuracy]
    accuracy_norm = [acc/max(accuracy_norm)*5 for acc in accuracy_norm]
    
    # 最小工作范围，越小越好
    range_min_norm = [1/r for r in range_min]
    range_min_norm = [r/max(range_min_norm)*5 for r in range_min_norm]
    
    # 最大工作范围，越大越好
    range_max_norm = [r/max(range_max)*5 for r in range_max]
    
    return {
        '精度': accuracy_norm,
        '最小工作距离': range_min_norm,
        '最大工作距离': range_max_norm,
        '成本效益': [6-c for c in cost],  # 反转成本，值越高越好
        '采集速度': speed
    }

# 模拟3D点云生成
def generate_sample_point_cloud(technique, n_points=1000):
    """根据不同技术特点生成模拟点云"""
    # 基础形状 - 一个简单物体
    x = np.random.normal(0, 1, n_points)
    y = np.random.normal(0, 1, n_points)
    z = np.random.normal(0, 1, n_points)
    
    # 不同技术的特点
    if technique == '结构光':
        # 较为均匀、精确的点云
        noise = np.random.normal(0, 0.05, n_points)
    elif technique == '双目视觉':
        # 稀疏点云，精度中等
        noise = np.random.normal(0, 0.2, n_points)
        mask = np.random.choice([0, 1], size=n_points, p=[0.3, 0.7])
        x, y, z = x*mask, y*mask, z*mask
    elif technique == '飞行时间':
        # 分辨率较低，噪声较大
        noise = np.random.normal(0, 0.3, n_points)
        x = np.round(x * 3) / 3  # 模拟较低分辨率
        y = np.round(y * 3) / 3
        z = np.round(z * 3) / 3
    else:
        noise = np.random.normal(0, 0.1, n_points)
    
    # 添加噪声
    z = z + noise
    
    return x, y, z

# 可视化不同技术的点云特点
def visualize_point_clouds():
    fig = plt.figure(figsize=(15, 10))
    
    techniques_to_show = ['结构光', '双目视觉', '飞行时间']
    
    for i, technique in enumerate(techniques_to_show):
        ax = fig.add_subplot(2, 2, i+1, projection='3d')
        
        x, y, z = generate_sample_point_cloud(technique)
        ax.scatter(x, y, z, c=z, cmap='viridis', s=10, alpha=0.6)
        
        ax.set_title(f'{technique}技术点云特点', fontsize=12)
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')
        ax.set_xlim(-2, 2)
        ax.set_ylim(-2, 2)
        ax.set_zlim(-2, 2)
    
    # 添加一个3D技术示意图
    ax = fig.add_subplot(2, 2, 4)
    ax.axis('off')
    ax.text(0.5, 0.9, '3D检测技术原理示意', ha='center', fontsize=14)
    
    # 添加简单技术原理图示
    techniques_desc = {
        '结构光': '投影散斑或条纹图案，\n通过畸变计算深度',
        '双目视觉': '两个相机从不同角度拍摄，\n计算视差得到深度',
        '飞行时间': '测量光信号往返时间\n计算物体距离'
    }
    
    for i, (tech, desc) in enumerate(techniques_desc.items()):
        ax.text(0.1, 0.7 - i*0.25, f"{tech}:", fontweight='bold')
        ax.text(0.2, 0.65 - i*0.25, desc, fontsize=10)
    
    plt.tight_layout()
    return fig

# 3D点云表示方法对比
def visualize_3d_representations():
    fig = plt.figure(figsize=(15, 5))
    
    # 创建基础形状
    x = np.linspace(-1, 1, 20)
    y = np.linspace(-1, 1, 20)
    X, Y = np.meshgrid(x, y)
    Z = np.sin(np.sqrt(X**2 + Y**2))
    
    # 1. 点云表示
    ax1 = fig.add_subplot(131, projection='3d')
    x_pts = X.flatten()
    y_pts = Y.flatten()
    z_pts = Z.flatten()
    ax1.scatter(x_pts, y_pts, z_pts, c=z_pts, cmap='viridis', s=20)
    ax1.set_title('点云表示')
    
    # 2. 网格表示
    ax2 = fig.add_subplot(132, projection='3d')
    ax2.plot_surface(X, Y, Z, cmap='viridis', alpha=0.8, edgecolor='none')
    ax2.set_title('网格表示')
    
    # 3. 体素表示
    ax3 = fig.add_subplot(133, projection='3d')
    # 简化的体素表示：量化成较大的立方体
    voxel_size = 0.2
    x_voxel = np.round(x_pts / voxel_size) * voxel_size
    y_voxel = np.round(y_pts / voxel_size) * voxel_size
    z_voxel = np.round(z_pts / voxel_size) * voxel_size
    
    # 创建唯一体素位置
    voxels = set(zip(x_voxel, y_voxel, z_voxel))
    
    # 绘制体素
    for vx, vy, vz in voxels:
        # 创建一个微小的偏移以便看到体素
        vs = voxel_size * 0.9
        ax3.bar3d(vx-vs/2, vy-vs/2, vz-vs/2, vs, vs, vs, color='lightblue', alpha=0.7)
    
    ax3.set_title('体素表示')
    
    plt.tight_layout()
    return fig

# 执行可视化
metrics_normalized = normalize_metrics()
radar_fig, _ = radar_chart(techniques, metrics_normalized)
plt.figure(radar_fig.number)
plt.show()

point_clouds_fig = visualize_point_clouds()
plt.figure(point_clouds_fig.number)
plt.show()

representations_fig = visualize_3d_representations()
plt.figure(representations_fig.number)
plt.show()
```
- 记录：
    - 3D检测技术选型经验：

## 结构光技术
- 结构光原理与类型
- 投影图案设计
- 相位展开技术
- 深度计算方法
- 结构光系统设计
- 记录：
    - 结构光系统参数优化：

## 双目立体视觉
- 立体视觉原理
- 视差计算方法
- 立体匹配算法
- 深度图生成
- 相机配置与参数
- 记录：
    - 双目系统选型考量：

## TOF技术
- 飞行时间测量原理
- TOF相机类型与特点
- 测量精度与影响因素
- 误差来源与校正
- 应用场景与限制
- 记录：
    - TOF技术应用案例：

## 3D点云处理
- 点云滤波与降噪
- 点云配准技术
- 表面重建算法
- 点云特征提取
- 点云分割与聚类
- 记录：
    - 点云处理流程优化：

## CAD模型匹配
- CAD模型导入与处理
- 特征匹配与配准
- ICP算法与变体
- 几何特征提取
- 偏差分析与可视化
- 记录：
    - CAD匹配精度提升方法：

## 表面缺陷检测
- 三维表面缺陷类型
- 曲面拟合与分析
- 局部特征分析
- 法向量异常检测
- 缺陷深度与体积测量
- 记录：
    - 表面检测算法比较：

## 尺寸测量与公差
- 3D测量原理与方法
- GD&T标准应用
- 测量不确定度分析
- 形位公差评估
- 尺寸报告生成
- 记录：
    - 尺寸测量精度保证：

## 系统标定与精度
- 3D系统标定方法
- 标定板设计
- 多传感器融合标定
- 精度验证方法
- 环境因素影响
- 记录：
    - 标定流程与经验：

## 三维重建应用
- 逆向工程应用
- 装配验证系统
- 复杂零件检测
- 多视图重建技术
- 大场景重建
- 记录：
    - 3D重建应用案例：

## 学习资源与书签
- 3D技术标准与规范
- 开源点云处理库
- 硬件与软件资源
- 学习资源与社区
- 记录：
    - 资源链接：

## 学习进度与 TODO 列表
- [ ] 3D检测技术基础学习
- [ ] 结构光系统设计实践
- [ ] 点云处理算法研究
- [ ] CAD模型匹配实现
- [ ] 3D系统标定与精度测试
- 自定义进度记录区：

---

备注：每个章节下可按"要点 / 代码示例 / 习题 / 参考链接 / 个人笔记"五小节结构补充内容。