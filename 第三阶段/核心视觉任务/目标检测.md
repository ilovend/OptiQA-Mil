# 目标检测学习笔记 — 框架

说明：本文件为学习目标检测技术的笔记框架，后续在对应小节补充要点、示例、习题与心得。

## 目录
- [目标检测概述](#目标检测概述)
- [传统目标检测方法](#传统目标检测方法)
- [两阶段检测器](#两阶段检测器)
- [单阶段检测器](#单阶段检测器)
- [目标检测数据集与标注](#目标检测数据集与标注)
- [评价指标](#评价指标)
- [损失函数设计](#损失函数设计)
- [检测模型优化](#检测模型优化)
- [小目标检测](#小目标检测)
- [密集物体检测](#密集物体检测)
- [部署与优化](#部署与优化)
- [工业检测应用](#工业检测应用)
- [学习资源与书签](#学习资源与书签)
- [学习进度与 TODO 列表](#学习进度与-todo-列表)

---

## 目标检测概述
- 目标检测的定义与任务
- 检测与分类的区别
- 定位与分类的结合
- 检测算法的发展历程
- 工业领域的检测需求
- 示例：
```python
# 目标检测可视化示例
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches

# 创建一个模拟的检测结果可视化函数
def visualize_detection(image, boxes, labels, scores, class_names):
    """
    可视化目标检测结果
    
    参数:
    - image: 输入图像 (H, W, C)
    - boxes: 边界框坐标 [[x1, y1, x2, y2], ...]
    - labels: 类别索引
    - scores: 置信度分数
    - class_names: 类别名称列表
    """
    plt.figure(figsize=(12, 10))
    plt.imshow(image)
    ax = plt.gca()
    
    # 为每个类别分配不同颜色
    colors = plt.cm.hsv(np.linspace(0, 1, len(class_names)))
    
    for box, label, score in zip(boxes, labels, scores):
        # 获取当前类别的颜色
        color = colors[label]
        
        # 创建矩形
        x1, y1, x2, y2 = box
        rect = patches.Rectangle((x1, y1), x2-x1, y2-y1, 
                                linewidth=2, edgecolor=color, facecolor='none')
        ax.add_patch(rect)
        
        # 添加类别标签和置信度
        class_name = class_names[label]
        text = f"{class_name}: {score:.2f}"
        plt.text(x1, y1-5, text, color=color, fontsize=10,
                 bbox=dict(facecolor='white', alpha=0.7))
    
    plt.axis('off')
    plt.tight_layout()
    plt.show()

# 创建模拟数据
# 1. 生成一张随机图像
image = np.random.rand(500, 700, 3)

# 2. 模拟一些目标
# 在图像中添加一些简单的形状作为"目标"
# 矩形1
image[100:200, 150:250, 0] = 0.8
image[100:200, 150:250, 1:] = 0.2

# 矩形2
image[300:350, 400:500, :2] = 0.8
image[300:350, 400:500, 2] = 0.2

# 矩形3
image[250:350, 100:180, 0] = 0.2
image[250:350, 100:180, 1] = 0.8
image[250:350, 100:180, 2] = 0.2

# 矩形4 - 小目标
image[50:80, 500:530, :] = 0.9

# 3. 模拟检测结果
boxes = [
    [150, 100, 250, 200],  # [x1, y1, x2, y2]
    [400, 300, 500, 350],
    [100, 250, 180, 350],
    [500, 50, 530, 80]
]

labels = [0, 1, 2, 0]  # 类别索引
scores = [0.95, 0.87, 0.92, 0.75]  # 置信度
class_names = ['螺丝', '弹簧', '垫片', '芯片']  # 类别名称

# 可视化检测结果
visualize_detection(image, boxes, labels, scores, class_names)

# 模拟检测模型输出的特征图与锚点
def visualize_feature_anchors(image_size=(500, 700), grid_sizes=[(4, 5), (8, 10), (16, 20)]):
    """可视化不同特征图尺度和对应的锚点"""
    fig, axes = plt.subplots(1, len(grid_sizes), figsize=(15, 5))
    
    for i, (h, w) in enumerate(grid_sizes):
        # 创建网格点
        y, x = np.mgrid[0:image_size[0]:image_size[0]/h, 0:image_size[1]:image_size[1]/w]
        points = np.stack([x.ravel(), y.ravel()], axis=1)
        
        # 可视化
        axes[i].imshow(np.zeros(image_size), cmap='gray')
        axes[i].scatter(points[:, 0], points[:, 1], c='r', s=10)
        axes[i].set_title(f"特征图尺寸: {h}x{w}\n锚点数: {len(points)}")
        
        # 绘制部分锚框(简化示意)
        for j in range(0, len(points), len(points)//5):  # 只绘制部分锚框
            cx, cy = points[j]
            # 为每个锚点绘制不同尺寸的锚框
            w_h_ratios = [(30, 30), (45, 20), (20, 45)]
            for w_box, h_box in w_h_ratios:
                rect = patches.Rectangle(
                    (cx-w_box/2, cy-h_box/2), w_box, h_box,
                    linewidth=1, edgecolor='blue', facecolor='none', alpha=0.5
                )
                axes[i].add_patch(rect)
        
        axes[i].axis('off')
    
    plt.tight_layout()
    plt.suptitle("目标检测中的特征图与锚点", fontsize=14)
    plt.show()

# 可视化不同尺度的特征图和锚点
visualize_feature_anchors()
```
- 记录：
    - 目标检测核心概念：

## 传统目标检测方法
- 滑动窗口技术
- HOG与DPM
- 选择性搜索算法
- Haar特征与级联分类器
- 传统方法的局限性
- 记录：
    - 传统方法适用场景：

## 两阶段检测器
- R-CNN系列演进
- Fast R-CNN架构
- Faster R-CNN设计
- RoI Pooling与RoI Align
- FPN特征金字塔网络
- 记录：
    - 两阶段检测器选择：

## 单阶段检测器
- YOLO系列演进
- SSD架构设计
- RetinaNet与Focal Loss
- FCOS无锚点检测
- YOLOX与YOLOV5/V8比较
- 记录：
    - 单阶段检测器性能对比：

## 目标检测数据集与标注
- 公开数据集（PASCAL VOC、COCO）
- 工业检测数据集特点
- 数据标注规范
- 数据增强策略
- 特殊场景数据构建
- 记录：
    - 数据集构建经验：

## 评价指标
- 精确率与召回率
- AP与mAP计算
- IoU阈值选择
- COCO评价指标
- 工业应用中的评价指标
- 记录：
    - 评估指标选择依据：

## 损失函数设计
- 分类损失
- 回归损失（Smooth L1、IoU系列损失）
- 多任务损失平衡
- 正负样本平衡
- 损失函数演进
- 记录：
    - 损失函数优化经验：

## 检测模型优化
- NMS与Soft-NMS
- Anchor设计优化
- 特征融合技术
- 注意力机制应用
- 检测头设计
- 记录：
    - 模型优化技巧：

## 小目标检测
- 小目标定义与挑战
- 多尺度特征融合
- 超分辨率技术应用
- 特征增强技术
- 工业场景中的小目标检测
- 记录：
    - 小目标检测策略：

## 密集物体检测
- 密集场景检测挑战
- 重叠目标处理
- 非极大值抑制优化
- 实例分割辅助
- 密集场景数据增强
- 记录：
    - 密集检测解决方案：

## 部署与优化
- 模型量化与剪枝
- TensorRT加速
- ONNX格式转换
- 边缘设备部署
- 实时检测优化
- 记录：
    - 部署优化经验：

## 工业检测应用
- 缺陷检测应用
- 装配检验应用
- 零件识别与定位
- 多目标追踪结合
- 系统集成方案
- 记录：
    - 应用案例分析：

## 学习资源与书签
- 经典论文列表
- 开源实现与比较
- 教程与课程
- 竞赛与基准测试
- 记录：
    - 资源链接：

## 学习进度与 TODO 列表
- [ ] 检测基础理论学习
- [ ] 两阶段检测器掌握
- [ ] 单阶段检测器实践
- [ ] 检测模型优化技术
- [ ] 工业应用实施
- 自定义进度记录区：

---

备注：每个章节下可按"要点 / 代码示例 / 习题 / 参考链接 / 个人笔记"五小节结构补充内容。